<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="3.9.3">Jekyll</generator><link href="http://localhost:4000/feed.xml" rel="self" type="application/atom+xml" /><link href="http://localhost:4000/" rel="alternate" type="text/html" /><updated>2023-08-29T19:16:29+09:00</updated><id>http://localhost:4000/feed.xml</id><title type="html">Hello,UserErrorWorld</title><subtitle>Bon Voyage over Error</subtitle><author><name>Hyemi Jeong</name></author><entry><title type="html">[aiffel] Day 37</title><link href="http://localhost:4000/AIFFEL-DAY-37/" rel="alternate" type="text/html" title="[aiffel] Day 37" /><published>2021-02-22T00:00:00+09:00</published><updated>2021-02-22T00:00:00+09:00</updated><id>http://localhost:4000/%5BAIFFEL%5D-DAY-37</id><content type="html" xml:base="http://localhost:4000/AIFFEL-DAY-37/"><![CDATA[<h1 id="fundamental">Fundamental</h1>

<h2 id="딥러닝-레이어의-이해1--linear-convolution">딥러닝 레이어의 이해(1) : linear, convolution</h2>

<ul>
  <li>레이어의 정의 : 하나의 물체가 여러 개의 논리적인 객체들로 구성되어 있는 경우, 각 개체를 하나의 레이어라 정의함</li>
</ul>

<h3 id="linear-layer">Linear layer</h3>

<ul>
  <li>별칭 : Fully Connected Layer, Feedforward Neural Network, Multilayer perceptrons, Dense Layer…</li>
  <li>Weight의 모든 요소를 Parameter라고 부른다.</li>
</ul>

<p>텐서플로우의 주요 코드 설명</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">import</span> <span class="nn">tensorflow</span> <span class="k">as</span> <span class="n">tf</span>

<span class="c1">### 중간 생략
### (4,2) 차원인 boxes를 (4,3)으로 확장시키는 Linear Layer
</span><span class="n">boxes</span> <span class="o">=</span> <span class="n">tf</span><span class="p">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">batch_size</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">2</span><span class="p">))</span>
<span class="n">first_linear</span> <span class="o">=</span> <span class="n">tf</span><span class="p">.</span><span class="n">keras</span><span class="p">.</span><span class="n">layers</span><span class="p">.</span><span class="n">Dense</span><span class="p">(</span><span class="n">units</span><span class="o">=</span><span class="mi">3</span><span class="p">,</span> <span class="n">use_bias</span><span class="o">=</span><span class="bp">False</span><span class="p">)</span>
<span class="n">first_weight_shape</span> <span class="o">=</span>  <span class="n">first_linear</span><span class="p">.</span><span class="n">weights</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">shape</span>

<span class="c1">### 4차원의 입력값을 하나의 실수로 만드는 Linear Layer
### 2단계를 거쳐야 한다
### 먼저 (4,3) -&gt; (4,1) 로 만들어 준다. 
</span><span class="n">second_linear</span> <span class="o">=</span> <span class="n">tf</span><span class="p">.</span><span class="n">keras</span><span class="p">.</span><span class="n">layers</span><span class="p">.</span><span class="n">Dense</span><span class="p">(</span><span class="n">units</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">use_bias</span><span class="o">=</span><span class="bp">False</span><span class="p">)</span>
<span class="n">second_out</span> <span class="o">=</span> <span class="n">second_linear</span><span class="p">(</span><span class="n">first_out</span><span class="p">)</span>
<span class="n">second_out</span> <span class="o">=</span> <span class="n">tf</span><span class="p">.</span><span class="n">squeeze</span><span class="p">(</span><span class="n">second_out</span><span class="p">,</span> <span class="n">axis</span><span class="o">=-</span><span class="mi">1</span><span class="p">)</span>
<span class="c1">### 그리고 (4,1) 을 1차원 데이터로 바꿔주기 위해 Dense를 한번 더 거친다. 
</span><span class="n">third_linear</span> <span class="o">=</span> <span class="n">tf</span><span class="p">.</span><span class="n">keras</span><span class="p">.</span><span class="n">layers</span><span class="p">.</span><span class="n">Dense</span><span class="p">(</span><span class="n">units</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">use_bias</span><span class="o">=</span><span class="bp">False</span><span class="p">)</span>
<span class="n">third_out</span> <span class="o">=</span> <span class="n">third_linear</span><span class="p">(</span><span class="n">second_out</span><span class="p">)</span>
<span class="n">third_out</span> <span class="o">=</span> <span class="n">tf</span><span class="p">.</span><span class="n">squeeze</span><span class="p">(</span><span class="n">third_out</span><span class="p">,</span> <span class="n">axis</span><span class="o">=-</span><span class="mi">1</span><span class="p">)</span>

</code></pre></div></div>

<ul>
  <li>
    <p>Convolution Layer</p>
  </li>
  <li>
    <p>pooling layer : 핵심만 추리는 것</p>

    <p>Receptive Field : 뉴럴 네트워크의 출력부에서 충분한 정보를 얻기 위해 커버하는 입력 데이터의 인식 영역이 커서, 그 안에 찾고자 하는 객체의 특성이 충분히 포함되어 있어야 정확한 인식이 가능하게 된다.</p>
  </li>
  <li>
    <p>Max pooling의 장점</p>
    <ul>
      <li>translational invariance : 객체 위치에 대한 오버피팅 방지</li>
      <li>non-linear 함수와 동일한 피처 추출 효과</li>
      <li>receptive field 극대화 효과 : max pooling 없이 이런 효과를 보려면 convolutional layer를 수없이 쌓아야 한다.</li>
      <li>cf ) dilated convolution(팽창된 컨볼루션) : 이전의 필터는 가중치들이 모여있는 형태라면 이 필터를 사방으로 밀어서 팽창시킨다. 풍선에 점 찍어놓고 바람 부는 것을 생각해 보자.</li>
    </ul>
  </li>
</ul>

<h2 id="cs231n-10">CS231n-10</h2>

<p>Recurrent Neural Networks(RNN)</p>

<p>vanila neural network : feed-forward neural network(linear layer)</p>

<p>연속적인 데이터에 대해 일어나는 학습의 경우</p>

<p>RNN은 가변길이의 데이터에 대응할 수 있다. 혹은 입/출력이 고정된 경우라 해도 ‘가변 과정’인 경우에 유리하다.</p>

<p>숫자 데이터에 대해서 어떻게 대응하는지 예시를 보여준다.</p>

<p>RNN의 구조는 재귀적이다. 이전 스텝의 결과와 어떤 시점의 벡터를 함수의 입력으로 받는다. 여기서 쓰이는 함수와 함수에서 사용하는 가중치(W)는 변화하지 않는다.</p>

<p>각 단계에서 같은 W를 쓴다.</p>

<p>Many -to-Many의 경우는 각 단계의 출력이 output이고, local loss를 구해서 전체의 loss를 구한다. -&gt; 각 단계에서 개별로 local Gradient들을 구해서 W에 업데이트한다.</p>

<p>Many-to-One의 경우는 마지막 히든 스테이지의 출력이 결과값이 된다.</p>

<p>One-to-Many는 입력은 고정이지만 출력은 가변이다. 입력값이 초기 히든 스테이트를 초기화한다.</p>

<p>그렇다면 Many-to-one과 one-to-many를 합치면? Sequence to Sequence</p>

<p>Encoder(many to one)와 Decoder(one to many)로 이루어진다. 입력을 하나의 백터로 요약하고, 하나의 벡터 입력에서 출력을 얻어낸다. ‘자연어’처리와 관련되어있는 모델이다.</p>

<p>input -&gt; hidden -&gt; output -&gt; softmax(output에서 sample을 뽑기 위해 확률분포를 사용) -&gt; sample -&gt; 다음 인풋으로 sample 넣어주기(input과 sample은 둘 다 정보를 가진 vector. 예를 들면 one-hot-vector로)</p>

<p>근데 왜 확률분포를 사용하는가? 모델에서 다양성을 얻기 위해서. 항상 같은 접두사나 같은 이미지를 넣을 경우 argmax로 sample을 고르면 다양한 값이 나오지 않을 수 있다.</p>

<p>‘sampling’ -&gt; softmax로 확률분포를 취한다고 해도 sampling 설명이 어색해서, ‘teacher forcing’을 도입해서 사용한다. 원래는 확률이 가장 높은 것을 취한다고 해도, ‘의도하는 바(자연어는 말하는 순서가 정해져 있으니까 순서라고 얘기할 수 있다.)를 강요’하는 것이다.</p>

<p>Truncated Backpropagation through time</p>

<p>만약 시퀸스의 길이가 엄청나게 길어진다면 앞부분의 정보가 사라지는 단점이 있다. 그래서 긴 시퀸스를 쪼개서 덩어리로 보는 개념이 Truncated Backpropagation이다. 결국 배치로 잘라서 보는 것이다.</p>

<p>RNN에는 hidden vector가 있고 이 vector를 계속 업데이트한다. RNN의 Cell은 보통 해석하기 힘들다. 해석할 수 있는 cell을 찾을 때 까지 가 보면, 그 모델이 학습하고자 하는 목표에 가까워지는 것을 볼 수 있다.</p>]]></content><author><name>Hyemi Jeong</name></author><summary type="html"><![CDATA[Fundamental]]></summary></entry><entry><title type="html">[aiffel] Day 36</title><link href="http://localhost:4000/AIFFEL-DAY-36/" rel="alternate" type="text/html" title="[aiffel] Day 36" /><published>2021-02-19T00:00:00+09:00</published><updated>2021-02-19T00:00:00+09:00</updated><id>http://localhost:4000/%5BAIFFEL%5D-DAY-36</id><content type="html" xml:base="http://localhost:4000/AIFFEL-DAY-36/"><![CDATA[<h1 id="지시딥-준비">지시딥 준비</h1>

<h2 id="부제--밑바닥부터-시작하는-딥러닝-1권-5장">부제 : 밑바닥부터 시작하는 딥러닝 1권 5장</h2>

<h3 id="사전학습">사전학습</h3>

<p>일단 앞 부분을 다시 듣고 수식 전개를 해야할 것 같다. 이 부분이 어렵게 느껴지는건 당연하다고 하니 다행이다. 그리고 효율적인 전파와 역전파 계산을 위해 중간 결과값들을 캐시하는게 맞았다. 코드로 어떻게 구현하는 지가 궁금했는데 이렇게 하는거구나…</p>

<h3 id="역전파">역전파</h3>

<p>역전파가 하는 일은 연쇄 법칙의 원리와 같다</p>

<p>덧셈 노드의 경우는 미분하면 1이 나와서 1을 역전파로 전해진 값에 곱하는 거라 입력된 값을 그대로 다음 노드로 전하게 된다.</p>

<p>곱셈 노드의 경우 상류의 값에 순전파 때의 입력 신호들을 서로 바꾼 값을 곱해서 하류로 보낸다. 미분할때 다른 변수는 상수로 취급하니까.</p>

<p>#### ReLU</p>

<p>미분하면 입력값이 0보다 클때 1, 0 이하면 0이라서 0 이하로 신호가 들어오면 역전파 때는 더 이상 신호가 전파되지 않는다. (0을 보내버림). 전기 회로의 ‘스위치’ 에 비유할 수 있다고.</p>

<h4 id="sigmoid-계층">Sigmoid 계층</h4>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">y</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">/</span> <span class="p">(</span><span class="mi">1</span> <span class="o">+</span> <span class="n">exp</span><span class="p">(</span><span class="o">-</span><span class="n">x</span><span class="p">))</span>
</code></pre></div></div>

<p>연쇄법칙에 따라서 정리하면 <code class="language-plaintext highlighter-rouge">델타y(1-y)</code>로 정리된다. 와…! 순전파의 출력(y)만으로 계산할 수 있겠군.</p>

<h4 id="affine">Affine</h4>

<p>신경망의 순전파 때 수행하는 행렬의 곱을 기하학에서는 affine 변환이라고 부른다.</p>

<p>해당 책의 코드에서는 X * W + B = O로 표현하고 있다. 앞의 계산 그래프들에서는 단일 실수값을 통과시켰는데 이제는 계산 그래프 간에 행렬이 지나가는 것이다.</p>

<ul>
  <li>더 알아볼 점 : 행렬이 끼여 있을 때의 미분</li>
</ul>]]></content><author><name>Hyemi Jeong</name></author><summary type="html"><![CDATA[지시딥 준비]]></summary></entry><entry><title type="html">[aiffel] Day 34</title><link href="http://localhost:4000/AIFFEL-DAY-34/" rel="alternate" type="text/html" title="[aiffel] Day 34" /><published>2021-02-17T00:00:00+09:00</published><updated>2021-02-17T00:00:00+09:00</updated><id>http://localhost:4000/%5BAIFFEL%5D-DAY-34</id><content type="html" xml:base="http://localhost:4000/AIFFEL-DAY-34/"><![CDATA[<h1 id="코딩마스터">코딩마스터</h1>

<h2 id="프로그래머스">프로그래머스</h2>

<h3 id="12930">12930</h3>

<p>와..! 아니 이거 조심하자</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">str</span> <span class="o">=</span> <span class="s">"Line1-abcdef </span><span class="se">\n</span><span class="s">Line2-abc </span><span class="se">\n</span><span class="s">Line4-abcd"</span><span class="p">;</span>
<span class="k">print</span> <span class="nb">str</span><span class="p">.</span><span class="n">split</span><span class="p">(</span> <span class="p">)</span>
<span class="k">print</span> <span class="nb">str</span><span class="p">.</span><span class="n">split</span><span class="p">(</span><span class="s">' '</span><span class="p">,</span> <span class="mi">1</span> <span class="p">)</span>
</code></pre></div></div>

<p>이거 돌리면 어떻게 되게?</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">[</span><span class="s">'Line1-abcdef'</span><span class="p">,</span> <span class="s">'Line2-abc'</span><span class="p">,</span> <span class="s">'Line4-abcd'</span><span class="p">]</span>
<span class="p">[</span><span class="s">'Line1-abcdef'</span><span class="p">,</span> <span class="s">'</span><span class="se">\n</span><span class="s">Line2-abc </span><span class="se">\n</span><span class="s">Line4-abcd'</span><span class="p">]</span>
</code></pre></div></div>

<p>딜리미터가…사라집니다…코드는 ‘명확히’ 짤 것.</p>

<h3 id="42577">42577</h3>

<p>이거는 풀이가 여러 방면으로 나눌 것 같은데, 일단 문제조건을 보면 ‘어떤 번호가 다른 번호의 접두사가 되는 경우’라고 해서 엄청 복잡하게 생각했다. 한 번호가 여러 번호의 접두사가 될 건데, 어떻게 캐치해내지? 시간 복잡도는? 정리하면서 생각한 건데 완전탐색이 가장 일반적으로 생각할 수 있는 답이겠구나 싶다.</p>

<p>그래서 완전탐색을 하되, 좀 더 효율적으로 할 수 있는 방법을 생각했다.  길이별로 먼저 전화번호를 정렬해서 앞의 원소부터 다른 원소의 일부가 되는지를 확인하는 방법이 있었다.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">solution</span><span class="p">(</span><span class="n">phone_book</span><span class="p">):</span>
    
    <span class="n">phone_book</span><span class="p">.</span><span class="n">sort</span><span class="p">(</span><span class="n">key</span><span class="o">=</span><span class="nb">len</span><span class="p">)</span>
    <span class="n">answer</span> <span class="o">=</span> <span class="bp">True</span><span class="p">;</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">phone_book</span><span class="p">))</span> <span class="p">:</span> 
        <span class="k">if</span> <span class="n">answer</span> <span class="o">==</span> <span class="bp">False</span> <span class="p">:</span> 
            <span class="k">break</span>
        <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">phone_book</span><span class="p">))</span> <span class="p">:</span>
            <span class="k">if</span> <span class="nb">str</span><span class="p">(</span><span class="n">phone_book</span><span class="p">[</span><span class="n">j</span><span class="p">]).</span><span class="n">startswith</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">phone_book</span><span class="p">[</span><span class="n">i</span><span class="p">]))</span> <span class="p">:</span>
            <span class="c1"># 이 짓을 할 게 아니라 걍 phone_book[j]가 string이에요 선생님!
</span>                    <span class="n">answer</span> <span class="o">=</span> <span class="bp">False</span>
                    <span class="k">break</span>
    <span class="k">return</span> <span class="n">answer</span>
<span class="c1"># 효율성 테스트 1.17ms
</span></code></pre></div></div>

<p>이게…되네? 여기서  나는 숫자를 글자로 바꾸고 앞 부분을 비교하는 <code class="language-plaintext highlighter-rouge">startswith</code>를 사용했다.</p>

<p>**정정 : ** 전화번호부가 String으로 들어오기 때문에, 중간 과정이 필요없었다. python에서 sort를 쓰면 기본적으로 사전순으로 소팅을 한다.</p>

<h2 id="백준">백준</h2>

<p>ㅎㅎㅎ 백준에서 파이썬을 쓴게 처음이라서, 제출 시도부터가 글렀다. 그리고 의외로 python sort가 cost가 크지 않은게 신기했다. C++에서는 모든 연산에서 cost를 따졌으니까^^</p>

<p>그래서 이번 문제는 어차피 C++로 풀었지만, 다시 한번 python으로 풀면서 이번에는 백준을 쓰면 어떻게 파이썬을 제출해야 하는지 알아보겠습니다.</p>

<h4 id="입력은-어떻게-받을-것인가">입력은 어떻게 받을 것인가</h4>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">from</span> <span class="nn">sys</span> <span class="kn">import</span> <span class="n">stdin</span>
<span class="c1"># 입력받을 것이 하나
</span><span class="n">n</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">stdin</span><span class="p">.</span><span class="n">readline</span><span class="p">())</span>
<span class="c1"># 입력받을 것이 여러개
</span><span class="n">li</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="nb">int</span><span class="p">,</span> <span class="n">stdin</span><span class="p">.</span><span class="n">readline</span><span class="p">().</span><span class="n">split</span><span class="p">()))</span>
</code></pre></div></div>

<p>아 왜 못 풀었는지 알겠다…이거ㅠㅠㅠ 입력받은거 list로 감싸줘야 하는데 map하고 냅둬서 index로 참조를 못하는 상황이었다.</p>

<p>이번에 사용한 온라인 인터프리터는 이거 : https://repl.it/languages/python3</p>]]></content><author><name>Hyemi Jeong</name></author><summary type="html"><![CDATA[]]></summary></entry><entry><title type="html">[aiffel] Day 32</title><link href="http://localhost:4000/AIFFEL-DAY-32/" rel="alternate" type="text/html" title="[aiffel] Day 32" /><published>2021-02-15T00:00:00+09:00</published><updated>2021-02-15T00:00:00+09:00</updated><id>http://localhost:4000/%5BAIFFEL%5D-DAY-32</id><content type="html" xml:base="http://localhost:4000/AIFFEL-DAY-32/"><![CDATA[<h1 id="cs231n-7강">CS231n 7강</h1>

<p>저번시간 복습</p>

<p>internal covariant : 데이터 간의 분포가 달라지면 학습 결과가 달라질 수 있다.</p>

<p>Batch Normalization의 위치 : non-linearble 연산이 필요한 경우</p>

<p>그래서 normalization하는 단계는 2단계(normalization -&gt; network 학습 변수 적용)</p>

<p>모멘텀 기법 + gradient squared term</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">vx</span> <span class="o">=</span> <span class="mi">0</span>
<span class="k">while</span> <span class="bp">True</span> <span class="p">:</span>
    <span class="n">dx</span> <span class="o">=</span> <span class="n">compute_gradient</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
    <span class="n">vx</span> <span class="o">=</span> <span class="n">rho</span> <span class="o">*</span> <span class="n">vx</span> <span class="o">+</span> <span class="n">dx</span>
    <span class="n">x</span> <span class="o">+=</span> <span class="n">learning_rate</span> <span class="o">*</span> <span class="n">vx</span>
</code></pre></div></div>

<p>여기서 rho값이 velocity의 영향력을 조절하는데, 보통 0.9, 0.99와 같이 높은 값을 준다. 그래서 gradient vector가 바로 반영되는게 아니라 velocity의 영향을 받아서 나아가게 된다.</p>

<h3 id="adam">Adam</h3>

<p>bias correction에 대해서 좀 더 서술하자.</p>

<p>momentum + ada = adam</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">first_moment</span> <span class="o">=</span> <span class="mi">0</span>
<span class="n">second_moment</span> <span class="o">=</span> <span class="mi">0</span>
<span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">num_iterations</span><span class="p">)</span> <span class="p">:</span>
	<span class="n">dx</span> <span class="o">=</span> <span class="n">compute_gradient</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
    <span class="c1"># for momentum
</span>    <span class="n">first_moment</span> <span class="o">=</span> <span class="n">beta1</span> <span class="o">*</span> <span class="n">first_moment</span> <span class="o">+</span> <span class="p">(</span><span class="mi">1</span><span class="o">-</span><span class="n">beta1</span><span class="p">)</span> <span class="o">*</span> <span class="n">dx</span>
    <span class="c1"># for RMSProp
</span>    <span class="n">second_moment</span> <span class="o">=</span> <span class="n">beta2</span> <span class="o">*</span> <span class="n">second_moment</span> <span class="o">+</span> <span class="p">(</span><span class="mi">1</span><span class="o">-</span><span class="n">beta2</span><span class="p">)</span> <span class="o">*</span> <span class="n">dx</span> <span class="o">*</span> <span class="n">dx</span>
    <span class="c1"># bias correction start
</span>    <span class="n">first_unbias</span> <span class="o">=</span> <span class="n">first_moment</span> <span class="o">/</span> <span class="p">(</span><span class="mi">1</span><span class="o">-</span><span class="n">beta1</span><span class="o">**</span><span class="n">t</span><span class="p">)</span>
    <span class="n">second_unbias</span> <span class="o">=</span> <span class="n">second_moment</span> <span class="o">/</span> <span class="p">(</span><span class="mi">1</span><span class="o">-</span><span class="n">beta2</span><span class="o">**</span><span class="n">t</span><span class="p">)</span>
    <span class="c1"># bias correction end
</span>    <span class="c1"># AdaGrad / RMSProp
</span>    <span class="n">x</span> <span class="o">-=</span> <span class="n">learning_rate</span> <span class="o">*</span> <span class="n">first_unbias</span> <span class="o">/</span> <span class="p">(</span><span class="n">np</span><span class="p">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">second_unbias</span><span class="p">)</span> <span class="o">+</span> <span class="mf">1e-7</span><span class="p">)</span>
</code></pre></div></div>

<p>여기서 beta2 = 0.999, learning_rate = 1e-3 또는 5e-4</p>

<p>첫째 둘째 모멘트를 계산하고 난 다음에 그 둘에서 unbias 값을 계산한 후, 이를 다음 스텝에서 적용한다. (베타, 알파)</p>

<p>만약 unbias를 계산하지 않으면 다음의 문제가 생긴다. first_moment와 second_moment가 0에서 시작하는데, second_moment는 첫번째 스텝이 지나가도 0에 수렴하게 된다. 이를 보정하기 위해 Bias correction을 한다.</p>

<p>처음에는 learning rate를 높여서 학습하다가 그 이후에는 꾸준히 낮추면서 학습한다. (learning rate decay)</p>

<p>이 기법은 adam보다 sgd에서 더 많이 쓰이고, 부차적인 하이퍼파라미터가 된다. 정확도를 지켜보다가 필요하다 싶을 때 learning rate를 변경하면서.</p>

<p>First-order optimization : 그 시점에서의 접선의 기울기를 구하는 방법 -&gt;  second-order optimization이 나온듯.</p>

<p>1차 미분은 기울기, 2차 미분은 기울기의 양상을 구할수 있다!</p>

<p>Second-order optimization : 2차 미분의 양상을 사용한다. First-order를 사용하는 것보다 좋긴 한데, 사용할 수 있는 곳이 정해져 있다. Newton step. Hessian matrix. 여기서는 learning rate가 없다. 하이퍼파라미터도 없다. Hessian은 N^3를 사용하기 때문에, 딥러닝에서 활용할 수가 없다(무수한 차원을 생각해보라)</p>

<p>그래서 Quasi-Newton에서는 N^2로 줄지만 이래도 딥러닝에 활용하기에는 너무 크다. 만약 full-batch를 시도할거면, L-BFGS를 사용해봐라. (하지만 Adam을 쓰세요…)</p>

<h4 id="beyond-training-error">Beyond Training Error</h4>

<p>regularization에 대해서 다뤄볼 에정.</p>

<p>train과 test(validation)의 학습 결과를 줄이기 위해서 어떤 것을 해야 하나? : 독립적인 여러 모델 쓰고 앙상블 기법을 써서 결과의 평균을 사용하기. 근데 2프로 정도 증가한다고… (ex : imagenet)</p>

<p>좀 더 나아가면 모델들을 저장하고(snapshot) 앙상블로 사용해볼 수 있다. 학습 중간중간에 앙상블의 결과를 보고 이를 학습에 반영한다. 그래서 learning rate를 높였다 낮췄다 퐁당퐁당하면서 지나간다.</p>

<p>만약 평균을 낼 때 모델 간의 결과의 gap을 신경쓰지 않는다면 validation에 overfitting하면 되지 않을까 라는 단순한 원리로 접근할 수도 있다. poiyak averaging이라는 기법이 있다.</p>

<p>단일 모델의 성능을 향상시키려면 어떻게 해야할까?</p>

<h4 id="regularization--add-term-to-loss">Regularization : Add term to loss</h4>

<p>Training할 때 random noise를 더하고, testing때는 noise를 평균화.</p>

<p>L1, L2, Elastic net</p>

<p>Fully connected layer -&gt; 어떤 뉴런들을 렌덤하게 반영하지 않는다. 근데 너무 많은 특징을 반영하게 되면 랜덤하게 누락된 뉴런이 특징을 파악할 때 관여하는 경우 불리할 수 있다.</p>

<p>Dropout : Random mask를 쓰는 방법 (&lt;- 후에 복습하기!)</p>

<p>그렇다면 이를 test time에서 어떻게 dropout을 사용할까? Dropout한 만큼 test time에서 값을 증폭해야 한다. 하지만 inverted dropout이라는 것도 있는데 이건 train할때 떨군 확률 p를 나눠주고, test time에서는 이를 그냥 둔다.</p>

<p>average out —&gt; 이거 나중에 복습하기!</p>

<p>dropout이 적용되지 않은 노드에서만 back propagation이 일어난다. 결국 Reularization은 네트워크에 무작위성을 추가해서 train 데이터에 overfitting하는 문제를 막는다.  BN이랑 비슷한 효과를 얻을 수 있다. Dropout은 BN과 달리 자유롭게 조정할 수 있는 파라미터 p(drop 확률)가 존재한다.</p>

<h4 id="data-augmentation">Data Augmentation</h4>

<p>이미지의 일부를 잘라서 변형시켜 이를 test에 사용할 수 있다. 그리고 이 외에도 다양한 방법이 있는데, 핵심은 label을 유지하면서 데이터에 변형을 가하는 방법이다.</p>

<p>Fractional maxpooling : pooling할 지역이 random하게 지정된다.</p>

<p>stochastic depth에 대해서 : 곁보기에는 바로 직전의 결과물이 아닌 몇 스텝 이전의 결과물을 그 다음에 반영하는 걸로 보이는데…</p>

<p>보통은 BN을 많이 쓰지만 overfitting이 해결되지 않는다면 Dropout과 같은 다양한 방법을 추가해볼 수 있다.</p>

<p>transfer learning(꽤 유용한 방법) -&gt; 해커톤 같은 경우에 사용가능하다.</p>

<p>데이터가 얼마 없는 경우에 transfer learning을 사용한다. Fully connected layer쪽을 다시 학습시키는 방법을 사용한다. 비슷한 데이터셋의 경우에는 데이터셋 크기 작으면 선형 분류, 많으면 몇몇 레이어를 잘 튜닝시키고 다른 데이터들이 있는 데이터셋의 경우에는 다르게 대처한다.</p>

<p>데이터가 1M 이하면 transfer learning을 추천한다.</p>

<h1 id="cs231n-09">CS231n-09</h1>

<p>CNN output size calculator</p>

<p>you can use this formula <code class="language-plaintext highlighter-rouge">[(W−K+2P)/S]+1</code>.</p>

<ul>
  <li>W is the input volume - in your case 128</li>
  <li>K is the Kernel size - in your case 5</li>
  <li>P is the padding - in your case 0 i believe</li>
  <li>S is the stride - which you have not provided.</li>
</ul>

<p>파라미터의 수는 96 * 11 * 11 * 3</p>

<p>pooling layer에는 parameter가 없다. 왜냐하면 파라미터는 우리가 학습하는 가중치를 의미하는데, pooling의 연산은 학습하면서 적용할 가중치가 없기 때문이다.</p>

<p>AlexNet의 경우 모델을 2개로 나누어서 학습했는데 이유는 GPU 메모리 용량때문에(…)</p>

<p>VGGNet에 대해서 설명 :</p>

<p>Small filters, Deeper networks.</p>

<p>왜 크기가 작은 필터를 사용했나? 크기가 작은 필터를 여러 레이어에 걸쳐 적용한 것은 크기가 큰 필터를 한번 적용한 것과 같다. ( ex : 3x3 필터 세 번과 7x7 필터 한번 )</p>]]></content><author><name>Hyemi Jeong</name></author><summary type="html"><![CDATA[CS231n 7강]]></summary></entry><entry><title type="html">[aiffel] Day 29</title><link href="http://localhost:4000/AIFFEL-DAY-29/" rel="alternate" type="text/html" title="[aiffel] Day 29" /><published>2021-02-08T00:00:00+09:00</published><updated>2021-02-08T00:00:00+09:00</updated><id>http://localhost:4000/%5BAIFFEL%5D-DAY-29</id><content type="html" xml:base="http://localhost:4000/AIFFEL-DAY-29/"><![CDATA[<p>항상 gem과 jekyll이 문제다. 분명 그전날 세팅 다 했는데 다음날 충돌하는 모양을 보고 있노라면, 매우 허무해진다. 그래서 ruby부터 다시 깔았으므로, 다음에 충돌이 날 때는 어쩔 수 없다. PATH 확인하고, bundle이 의존하는 ruby를 에러메세지에서 주의깊게 살펴본 후 도저히 안되면 날려버리고 새로 세팅하라.</p>

<h1 id="cs231n-06">CS231n-06</h1>

<h2 id="batch-normalization">Batch normalization</h2>

<p>배치로 얻은 데이터가 나왔을 때, 각 배치의 평균과 분산을 통해 normalization 수행.</p>

<p>각 차원에서 평균과 분산을 구하고, 여기서 normalization을 수행한다. 보통 FC나 Convolutional layers 이후, 혹은 비선형 단계 전에 행한다.</p>

<p>근데 activation function의 input이 반드시 가우시안 분포를 따라야 하는가? 우리의 목표는 activation function에 들어오는 input이 의미있는 activation function의 output값을 가지도록 처리하는 것이다.</p>

<p>CNN에서는 activation map에서 데이터의 공간적인 관계를 유지하길 원하니까, 각 activation map간의 평균과 분산을 구해서 normalization 을 시도한다.</p>

<p><code class="language-plaintext highlighter-rouge">((layer input)-평균)/(분산) = 가우시안 분포</code></p>

<p>평균을 빼면 데이터가 0을 원점으로 위치하게 되고 분산으로 나누게 되면 데이터들이 0과 1사이에 분포하게 된다.</p>

<h2 id="babysitting-the-learning-process">Babysitting the learning process</h2>

<p>학습 과정이 어떻게 이루어지는지 보고 하이퍼파라미터를 어떻게 조정할 것인지에 대해서 배울 것.</p>

<p>네트워크를 초기화한다. foward pass를 시켜보고 loss가 제대로 이루어지는지 확인한다. 그리고 데이터의 일부만 학습시켜 본다. Overfit과 Loss가 생길거다. 이 때는 regularization을 하지 않는다. 그리고 아주 조금의 regularization을 적용해본다. 이렇게 조금씩 값을 바꿀 경우 이 상황의 경우 결과 값들의 확률이 고르게 분포하고 있고, accuracy는 이 비슷비슷한 값 중에서 제일 큰 값을 취하기 때문에 accuracy가 갑자기 커질 수 있다. learning rate를 키우게 되면 cost가 어떻게 되나? 너무 키우면 cost가 발산해 버린다.</p>

<h2 id="hyperparameter-optimization">Hyperparameter Optimization</h2>

<p>처음에는 파라미터의 효율성을 알기 위해서 적은 횟수의 학습을 돌린다. 두 번째에서는 더 많이 반복해서 더 정제된 결과를 얻는다. cost가 이전의 3배 이상으로 발산하면 잘못된 파라미터를 가지고 학습하고 있는 것. validation accuracy를 넣어서 학습하는데, 파라미터 값은 log scale의 값으로 샘플링하자. (이유 후술)</p>

<p>grid search는 어떤가? 하이퍼파라미터를 일정한 간격으로 증감시켜 파라미터를 넣어보는 것이다. 실제로는 random search가 더 잘 작동하지만.</p>

<p>validation accuracy는 높아지지 않는다.</p>

<h1 id="cs231n-07">CS231n-07</h1>

<h2 id="fancier-optimization">Fancier optimization</h2>

<p>손실 함수가 가중치에 대한 landscape라고 생각하자. gradient descent를 줄여나가는 과정에서, 기존의 SGD의 경우 목표축이 아닌 축의 방향에 대해서는 지그재그로 값이 흔들리면서 느리게 업데이트 되는 것을 볼 수 있다. 그리고 SGD에서 발생하는 다른 문제점은 local minima와 saddle point이다. 둘 다에 걸려버린다. saddle point는 gradient가 0에 가깝기 때문이다.</p>

<p>saddle point : 안장점. 변곡점이랑은 차원에 따라 같은 개념으로 취급하는 듯. 3차원으로 가면 2개의 변화지점이 겹치는 지점.</p>

<h3 id="부제--어떻게-learning-rate와-step의-크기를-제어할-수-있을까">부제 : 어떻게 learning rate와 step의 크기를 제어할 수 있을까?</h3>

<p>Momentum을 추가하면 이러한 흔들림을 해결할 수 있다. 파라미터 하나가 더 추가되는듯. Gradient와 velocity(gradient의 평균값)의 연산을 통해 실제 움직이는 과정을 정할 수 있다. Momentum, Nesterov Momentum. Nesterov Momentum에서는 Loss와 Gradient를 같은 점에서 계산하는 기존의 방식에서 살짝 변형을 주어 이전과 현재의 velocity간의 에러 보정이 들어가있다. Momentum은 단어 그대로 이전까지의 변화량을 바탕으로, 다음 스텝의 움직임에 이 변화량을 반영해 바로 gradient의 변화가 이루어지는게 아닌 이전 방향의 움직임에 영향을 받도록 하는 기법이다.</p>

<p>근데 만약 minima가 길고 좁을때 그냥 지나치면 어떡해? &gt; 흥미로운 부분이다. 사실 이런 특징을 가진 데이터는 바람직하진 않은데, 그래도 이걸 어떻게 해결할까에는 중요한 연구과제.</p>

<p>AdaGrad는 훈련 도중의 gradient를 사용한다. 앞서 게산한 gradient를 제곱한 값을 사용한다. 그래서 기울기가 큰 경우에는 속도가 느려지고, 기울기가 작은 경우에는 속도가 빨라진다. 이렇게 되면 학습 횟수가 늘어난다. 손실함수가 convex한 경우에는 minimun에 근접하면서 서서히 속도를 줄이는 게 좋은 현상이 될 수 있지만, non-convex한 케이스에서는 제대로 작동하지 않을 수 있다.</p>

<p>그래서 RMSProp에서 이러한 문제를 개선한다. AdaGrad는 learning rate의 문제로 잘 사용하지 않는다. 근데 왜 convex에서도 AdaGrad가 불리할까? AdaGrad는 learning rates가 계속 바뀌기 때문이다. 다른 알고리즘은 learning rate가 고정되지만.</p>]]></content><author><name>Hyemi Jeong</name></author><summary type="html"><![CDATA[항상 gem과 jekyll이 문제다. 분명 그전날 세팅 다 했는데 다음날 충돌하는 모양을 보고 있노라면, 매우 허무해진다. 그래서 ruby부터 다시 깔았으므로, 다음에 충돌이 날 때는 어쩔 수 없다. PATH 확인하고, bundle이 의존하는 ruby를 에러메세지에서 주의깊게 살펴본 후 도저히 안되면 날려버리고 새로 세팅하라.]]></summary></entry><entry><title type="html">[aiffel] Day 22</title><link href="http://localhost:4000/AIFFEL-DAY-22/" rel="alternate" type="text/html" title="[aiffel] Day 22" /><published>2021-01-27T00:00:00+09:00</published><updated>2021-01-27T00:00:00+09:00</updated><id>http://localhost:4000/%5BAIFFEL%5D-DAY-22</id><content type="html" xml:base="http://localhost:4000/AIFFEL-DAY-22/"><![CDATA[<h1 id="파이썬을-해봅시다">파이썬을 해봅시다</h1>

<p>오전 기초 과정에서는 파이썬 문법 심화, 오후 풀잎 시간에는 파이썬 공부 및 코테 풀어보기(프로그래머스)를 진행했다.</p>

<p>오늘 주목한 것 : immutable vs mutable</p>

<p>그래서 코드를 직접 짜봐서 테스트를 해봤다.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">print</span><span class="p">(</span><span class="s">"make 2 tuple variable"</span><span class="p">)</span>
<span class="n">a</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">])</span>
<span class="n">b</span> <span class="o">=</span> <span class="n">a</span>
<span class="k">print</span><span class="p">(</span><span class="nb">id</span><span class="p">(</span><span class="n">a</span><span class="p">),</span> <span class="nb">id</span><span class="p">(</span><span class="n">b</span><span class="p">))</span>
<span class="k">print</span><span class="p">(</span><span class="s">"assign new tuple at the other tuple"</span><span class="p">)</span>
<span class="n">b</span> <span class="o">=</span> <span class="n">a</span> <span class="o">+</span> <span class="p">(</span><span class="mi">4</span><span class="p">,)</span>
<span class="k">print</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
<span class="k">print</span><span class="p">(</span><span class="n">b</span><span class="p">)</span>
<span class="k">print</span><span class="p">(</span><span class="nb">id</span><span class="p">(</span><span class="n">a</span><span class="p">),</span> <span class="nb">id</span><span class="p">(</span><span class="n">b</span><span class="p">))</span>
<span class="k">print</span><span class="p">(</span><span class="s">"Is it possible to reassign new tuple to original variable?"</span><span class="p">)</span>
<span class="n">a</span> <span class="o">=</span> <span class="n">a</span> <span class="o">+</span> <span class="p">(</span><span class="mi">4</span><span class="p">,)</span>
<span class="k">print</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
<span class="k">print</span><span class="p">(</span><span class="nb">id</span><span class="p">(</span><span class="n">a</span><span class="p">))</span>
<span class="k">try</span> <span class="p">:</span>
    <span class="k">print</span><span class="p">(</span><span class="s">"How about change the element of tuple"</span><span class="p">)</span>
    <span class="n">a</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>
<span class="k">except</span> <span class="p">:</span>
    <span class="k">print</span><span class="p">(</span><span class="s">"this expression is invaild"</span><span class="p">)</span>
</code></pre></div></div>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>make 2 tuple variable
139912658793168 139912658793168
assign new tuple at the other tuple
(1, 2, 3)
(1, 2, 3, 4)
139912658793168 139912658652336
Is it possible to reassign new tuple to original variable?
(1, 2, 3, 4)
139912658652912
How about change the element of tuple
this expression is invaild
</code></pre></div></div>

<p>tuple은 ‘변경이 불가능한’ 자료구조다. 실제로 index로 원소에 접근해서 tuple을 조작하려고 할 때, 에러가 난다. 하지만 tuple에 새 원소를 더해서 다른 변수에 할당하는 것은 가능하다. 이로써 파이썬에서의 ‘변수’는 메모리 공간을 가리키는 역할을 하고, 이 메모리 공간에 변수를 사용해서 접근한 후 그 공간을 변경가능한지 여부가 immutable과 mutable을 나눈다고 결론지었다.</p>

<p>C++에서 리스트의 경우 각 리스트는 포인터의 연속이고, 각 포인터가 가리키는 메모리 공간은 불연속성을 띌 수도 있다고 배웠는데 파이썬의 리스트의 원소들은 메모리를 가리키는 포인터의 연속이고, 이 포인터를 통해 메모리에 접근해서 메모리가 담고 있는 값을 변경가능하다.</p>

<p>참고 : https://bearwoong.tistory.com/85</p>

<p>그리고 풀어본 문제는 이것!</p>

<ol>
  <li>https://programmers.co.kr/learn/courses/30/lessons/12915</li>
  <li>https://programmers.co.kr/learn/courses/30/lessons/12916</li>
  <li>https://programmers.co.kr/learn/courses/30/lessons/64061</li>
</ol>

<p>파이썬 람다식에 대한 공부가 더 필요할 듯 하다. 람다식을 쓰면 정렬을 할 때 기준을 내 마음대로 할 수 있다.</p>

<p>그리고 파이썬 빈 리스트을 초기화하는 방법에 대해서 다양한 방법들이 있는 듯 한데, 3번 문제는 다 풀어놓고 빈 배열을 간파해서 계속 out of range 에러가 났었다.</p>

<p>파이썬 정렬 시 sort함수는 원형 데이터를 바로 정렬하고, sorted함수는 원형을 보존하고 정렬 결과를 반환한다.  sorted함수에는 정렬 기준을 따로 줄 수 있는데, 람다식을 이용해서 1순위 기준, 2순위 기준을 한꺼번에 줄 수 있다.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">sorted</span><span class="p">(</span><span class="nb">sorted</span><span class="p">(</span><span class="n">strings</span><span class="p">),</span> <span class="n">key</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">strings</span> <span class="p">:</span> <span class="n">strings</span><span class="p">[</span><span class="n">n</span><span class="p">])</span>
</code></pre></div></div>

<p>이렇게 쓴 식을</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">answer</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">strings</span><span class="p">,</span> <span class="n">key</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">strings</span> <span class="p">:</span> <span class="p">(</span><span class="n">strings</span><span class="p">[</span><span class="n">n</span><span class="p">]</span> <span class="p">,</span><span class="n">strings</span><span class="p">))</span>
</code></pre></div></div>

<p>이렇게 다중 조건을 줄 수 있다.</p>

<p>그리고 파이썬의 리스트 초기화에 대해서 알아봤는데 내가 쓴 방법은 이거였다.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">list</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n</span><span class="p">)]</span>
</code></pre></div></div>

<p>그리고 list는 동적할당인데, numpy array는 정적할당이다! 조심할 것.</p>]]></content><author><name>Hyemi Jeong</name></author><summary type="html"><![CDATA[파이썬을 해봅시다]]></summary></entry><entry><title type="html">[aiffel] Day 20</title><link href="http://localhost:4000/AIFFEL-DAY-20/" rel="alternate" type="text/html" title="[aiffel] Day 20" /><published>2021-01-25T00:00:00+09:00</published><updated>2021-01-25T00:00:00+09:00</updated><id>http://localhost:4000/%5BAIFFEL%5D-DAY-20</id><content type="html" xml:base="http://localhost:4000/AIFFEL-DAY-20/"><![CDATA[<h1 id="cs231n-05">CS231n-05</h1>

<p>포스팅이 매우 격조했습니다. 한동안 컨디션이 매우 안좋았기 때문이죠. 주말동안 푹 쉰 건 아니지만 잘 먹어서 좀 나아진 듯 합니다. 매일 매일 기록하자! 가 모토인데 이제는 매일 매일 잠 잘 자고, 잘 따라가고, 적극적인 자세로 임하는 것이 목표가 되었습니다. 여러분, 건강하세요.</p>

<p>오늘의 그림 출처는 여기 : https://cding.tistory.com/5</p>

<h4 id="convnets의-원리">ConvNets의 원리</h4>

<p>4강을 들은 것을 정리를 안했는데, 4강 맨 끝에서 Fully Connected Layer에 대한 개념이 나온다. 그래서 잠깐 4강 끝에서 나왔던 Fully Connected Function에 대한 개념을 짚고 넘어가려고 한다.</p>

<h4 id="fully-connected-function">Fully Connected Function</h4>

<p>layer에 대한 input을 벡터 x라고 했을때 선형 함수의 형태로 score function을 구한다.</p>

<p><img src="https://t1.daumcdn.net/cfile/tistory/9955C8425B5741051C" alt="img" /></p>

<p>레이어 하나를 거치는 것은 W1을 곱하는 것이고, W2를 곱하게 되면 레이어 하나를 더 거치게 되는 것이다. 이 때, 다음 레이어로 가기 전에 그 전의 레이어의 결과물을 정제한다. 위의 그림에서 max 함수가 이런 역할을 하게 되며, 이를 <strong>activation function</strong>이라고 한다. activation function은 비선형 함수를 쓰게 되며,  비선형 함수의 종류는 다음과 같다.</p>

<p><img src="https://t1.daumcdn.net/cfile/tistory/99EB714D5B57410D16" alt="img" /></p>

<p>왜 비선형 함수를 쓰게 되냐면, 만약 이 때도 선형함수를 쓰게 되면 중간 결과값에 대해 가중치를 제대로 줄 수 없기 때문이다. 이 전에 인간의 신경망에 대한 설명이 나오는데, 차라리 역치 개념을 써놨더라면 ‘아. 신경망과 인공 지능망은 이런 공통점이 있구나!’ 라고 이해했을 걸…</p>

<blockquote>
  <p>하나의 레이어는 여러 개의 노드로 이루어져 있다. 레이어에 속한 하나의 노드에서는 다음과 같은 행동이 발생한다.  (이전 노드의 결과값) * (노드와 노드 간의 가중치)의 결과값 들을 받아들여 모두 더한다.(Wx, linear) 그리고 이 값에 activation함수를 적용해서 다음 노드로 전할 값을 결정한다.(non-linear)</p>
</blockquote>

<p>해당 구조에서 Layer를 여러개 두면 어떻게 될까? 다음과 같은 결과가 나오겠지.</p>

<p><code class="language-plaintext highlighter-rouge">(output) = Wn * max(Wn-1 * max(Wn-2...W2 * max(W1 * x, 0),0),0) (여기서 output layer는 마지막 layer의 노드수 * 1의 크기를 가지는 Wn을 통해 도출된다.)</code></p>

<p>이렇게 되면 해당 layer에 있는 모든 노드들은 다음 노드에 관여하게 되는 구조가 나온다. 그래서 Fully Connected Layer라고 부른다.</p>

<p><img src="https://t1.daumcdn.net/cfile/tistory/99DC70435B57410D02" alt="img" /></p>

<p>이제 다시 돌아가서, 5강의 처음은 Fully Connected Layer(<strong>Dense layer</strong>)에 대한 아이디어로부터 출발하게 된다.</p>

<h4 id="convolutional-neural-networks의-시작">Convolutional Neural Networks의 시작</h4>

<p><img src="https://t1.daumcdn.net/cfile/tistory/991CF9415B61925C1A" alt="img" /></p>

<p>행렬 곱은 (3072 x 1) * (10 x 3072) = (1 * 10) 이 나오게 된다. 이전 시간에 배웠던 Fully Connected Network의 원리를 생각해 보면 모든 input값은 다음 노드로 전달되니까 3072 x 1의 형태로 만든 것이고, hidden layer는 하나, class는 10개라서 output layer 모습이 1 * 10이 된다.</p>

<p>그렇다면 Convolutional Neural Network는 Fully Connected Layer에서 어떻게 나아갔을까?</p>

<p>데이터의 특성을 잘 반영하기 위해서 <strong>filter</strong>의 개념을 도입했다.</p>

<p>경험이 쌓이면 도움이 된다더니, 예전에 막내 국어 문제 풀어줄 때 나왔던 지문이 도움이 될 줄이야.</p>

<p><img src="https://t1.daumcdn.net/cfile/tistory/9989CC495D342D2D2A" alt="img" /></p>

<p>해당 문제는 2018년도 고2 모의평가 3월에 나왔던 지문인데, 풀어주면서도 ‘이걸 애들이 시간내에 풀 수 있을 거라고?’ 하며 연신 고개를 주억거렸던 기억이 난다. 이 그림은 필터를 통해 어떻게 이미지의 특성을 잡아내는지 그 예시를 들었다. 이 다음에 이 이미지를 보고 알맞게 추론한 것을 고르시오. 라는 문제와 함께 그림이 함께 나오는 예시가 나와서 명확히 기억한다.</p>

<p>필터는 이미지의 좌상단부터 훑는다. 그리고 필터의 모든 요소를 가지고 내적을 하며, 하나의 값을 얻게 된다. 이 과정이 위 그림의 첫번째 줄에 해당한다. 이 연산의 결과를 activation map에 저장하게 된다.</p>

<p>32x32x3을 5x5x3의 필터와 활성화 함수로 훑었을 때, 28x28x3의 activation map이 나온다.(n칸씩 뗄 지는 파라미터로 결정 =&gt; stride라고 한다.)</p>

<p><img src="https://t1.daumcdn.net/cfile/tistory/990AEF335B61926033" alt="img" /></p>

<p>정리하면 하나의 CNN은 filtering과 activation을 거친다. 그리고 하나의 activation map은 input data의 한 특성을 나타낸다. 바로 이렇게. 이 과정들을 반복하면  low-level features -&gt; mid-level features -&gt; high-level features 순으로 추출할 수 있다.</p>

<p><img src="https://t1.daumcdn.net/cfile/tistory/9987664E5B61D3FD07" alt="img" /></p>

<p>그래서 전체적인 Convolutional Neural Network는 다음과 같이 생겼다.</p>

<p><img src="https://t1.daumcdn.net/cfile/tistory/99546A3F5B61926206" alt="img" /></p>

<p>그런데 아까전의 예시에서는 한칸씩 필터를 밀었다. 필터를 한칸씩 말고 n칸씩 밀 수 있지 않을까? 이 때 어정쩡하게 남는 부분은 잘리게 되지 않을까? 그리고 input 데이터의 가장자리는 중앙보다 반영되는 횟수가 적지 않을까? 또 n칸씩 확 확 밀면 Layer 몇 개만 거쳐도 중간 값의 차원이 확 줄지 않을까?</p>

<p>그래서 <strong>Padding</strong>의 개념이 나오게 된다. Padding은 원본 데이터의 가장자리에 0으로 채운 행과 열을 더함으로써 위의 두가지 문제를 해결하게 된다.</p>

<p>테두리에 padding을 준다 : (N-F)/(stride+1). padding은 0으로 채운다.</p>

<p>그리고 중간에 이해 안가는 부분이 있어서 데려와봤다.</p>

<p><img src="https://t1.daumcdn.net/cfile/tistory/99CD73375B61D6EF18" alt="img" /></p>

<p>필터를 언급할 때 input 데이터의 depth에 대해서는 생략하고 얘기하더라. 적어도 해당 강의에서는. 그래서 조원들이랑 공부할 때 더더욱 헷갈렸다. 그림을 해석하면 다음과 같다.</p>

<ul>
  <li>1x1 conv with 32 filters : 1x1x64의 filter를 사용하며, 이를 32번 반복한다.</li>
  <li>결과값 56 x56 x 32 : 1x1x64를 한칸씩 밀어서 필터를 적용하고, 이에 activation function을 적용해서 만든 activation map의 크기는 56x56x1인데 이 과정을 32번 반복했으니까 depth는 32.</li>
</ul>

<p><img src="https://t1.daumcdn.net/cfile/tistory/9957CE405B61D6F10C" alt="img" /></p>

<p>해당 그림을 보니까 이전의 그림이 더 명확하게 이해되는데, 5개의 다른 필터를 사용해서 이 결과를 쌓으면 depth가 늘어난다. 그래. 필터를 다른 것을 쓴다고 얘기를 했어야지. 이 때 <code class="language-plaintext highlighter-rouge">필터 = 신경</code> 이렇게 치환해서 생각해보자.</p>

<h4 id="pooling">Pooling</h4>

<p>하지만 이 사이즈를 유지한 채로 계속해서 연산하게 된다면, 이는 성능에 영향을 주게 된다. 그래서 Pooling을 통해 Downsampling을 하게 된다.</p>

<p><img src="https://t1.daumcdn.net/cfile/tistory/99C286405B61D6F325" alt="img" /></p>

<p>해당 그림은 Pooling기법 중 Max를 이용하는 Max Pooling에 대해서 설명하고 있다. 간단하다. 해당 영역에서 max값만 뽑아서 다음 값으로 넘긴다. 마치 그림의 해상도를 n분의 1로 줄일 때 처럼 말이다.</p>

<h4 id="fully-connected-layer-in-cnn">Fully Connected Layer in CNN</h4>

<p>해당 레이어는 마지막에 쓰인다. class를 뽑아내야 하기 때문이다. 우리가 앞에서 Fully Connected Layer는 이런 것이라고 정의했기 때문에, 작동 원리를 생각해서 마지막에 이를 적용하게 되면 우리는 1x(클래스의 수) 크기를 가진 벡터를 얻을 수 있음을 알 수 있다.</p>

<h4 id="오늘의-후기">오늘의 후기</h4>

<p>아…진짜…어후…일단 Fully Connected Layer라는 용어를 유심히 보지 못하고 지나간 것이 화근이었다. 내가 기존에 알고 있던 기초적인 신경망 구조를 Fully Connected Layer라고 부르는 것을 몰랐다.</p>

<p>또 구체적인 예시를 들어야 할 때에는 정작 뭉뚱그려서 설명하는 강의의 방식, 표기법을 통일하지 않는 교재, 심지어 누락까지 되어 있어 이해를 더더욱 어렵게 만든다.</p>

<p>이제 확실히 알겠으니까 다음 강의를 기다려 본다. 이상 저번 강의부터 헷갈린 사람의 후기.</p>]]></content><author><name>Hyemi Jeong</name></author><summary type="html"><![CDATA[CS231n-05]]></summary></entry><entry><title type="html">[aiffel] Day 11</title><link href="http://localhost:4000/AIFFEL-DAY-11/" rel="alternate" type="text/html" title="[aiffel] Day 11" /><published>2021-01-12T00:00:00+09:00</published><updated>2021-01-12T00:00:00+09:00</updated><id>http://localhost:4000/%5BAIFFEL%5D-DAY-11</id><content type="html" xml:base="http://localhost:4000/AIFFEL-DAY-11/"><![CDATA[<h1 id="20210112">20210112</h1>

<h3 id="부제--스티커-사진-프로그램-만들기">부제 : 스티커 사진 프로그램 만들기</h3>

<p>오늘 노드에서는 얼굴 인식의 방법과 얼굴 인식 결과를 간단하게 응용해서 얼굴에 스티커를 붙이는 프로그램을 작성했다.</p>

<p>OpenCV의 기능들을 사용하는 게 중요했는데, OpenCV가 처리하는 이미지 데이터의 원하는 부분에 제대로 접근하려면 좌표 개념이 매우 중요하다. OpenCV는 행렬의 방식으로 데이터를 표현하고 있기 때문에, y축을 먼저 기술하고 x축을 기술하게 되며, <strong>좌상단이 원점</strong>이다.</p>

<p><img src="https://t1.daumcdn.net/cfile/tistory/2610B8475436287821" alt="카이제곱 :: '컴퓨터비전/영상처리' 카테고리의 글 목록 (5 Page)" /></p>

<p>이 좌표가 오늘의 핵심 키포인트. tmi로 계속 3차원 데이터를 다루다가 2차원 데이터를 다루게 되니 조금 어색했다. 3차원 좌표계는 또 달라서…</p>

<p>그리고 HOG 모델을 통해 얼굴의 특이점(landmark)을 추출해 내어 사진에서 얼굴을 찾을 수 있었다. 간단히 설명하면 이미지를 일정 구역들로 나누고 , 그 안에서 Gradient를 찾아낸다. 이 Gradient에서 얼굴 패턴으로 보이는 것을 찾아낸다.</p>

<p><img src="https://miro.medium.com/max/800/1*HtgQZ4guaIo8wflbsR1MLw.png" alt="Image for post" /></p>

<p><img src="https://blog.kakaocdn.net/dn/c8fGmV/btqGQcZBwNz/JzcH66lqvnxL7WDd3xo7EK/img.png" alt="얼굴인식 출입통제 프로그램을 만들어보세요.(유튜브 소개)" /></p>

<p>우리가 쓰는 카메라 어플에서 얼굴을 인식하는 방법 중 하나가 이 랜드마크를 사용하는 방법이라고 한다.</p>

<p>그리고는 스티커 사이즈를 얼굴 이미지에 따라 크기를 조정하고, 이미지 가공을 하게 된다. 스티커를 놓을 자리를 랜드마크의 좌표에 따라서 결정하고, 비율을 랜드마크를 이용해서 조절하게 된다.</p>

<p>이미지는 numpy의 array 타입으로 다룬다. 그리고 OpenCV의 기능을 활용하면 이미지 간의 연산이 가능하다. 이 둘을 적절히 조합하면 스티커를 이미지 위에 적절히 올릴 수 있다.</p>

<h4 id="후기">후기</h4>

<p>지금은 단순히 스티커가 놓일 위치를 해당하는 영역의 랜드마크들을 둘러싸는 bounding box로 구하고 있는데, 좀 더 정밀하게 하려면 랜드마크를 정확히 둘러싸는 minimum bounding box를 구하고,  affine transformation을 통해 얼굴의 각도가 틀어진다거나 하는 그런 경우에 대비할 수 있을 것이다.</p>

<p>노드 이제 정리하고 회고만 넣으면 끝!</p>

<p>오늘 노드 진행한 코드는 후에 보완할 예정입니다.</p>]]></content><author><name>Hyemi Jeong</name></author><summary type="html"><![CDATA[20210112]]></summary></entry><entry><title type="html">[AIFFEL] DAY 10</title><link href="http://localhost:4000/blog/AIFFEL-DAY-10/" rel="alternate" type="text/html" title="[AIFFEL] DAY 10" /><published>2021-01-11T00:00:00+09:00</published><updated>2021-01-11T00:00:00+09:00</updated><id>http://localhost:4000/blog/%5BAIFFEL%5D-DAY-10</id><content type="html" xml:base="http://localhost:4000/blog/AIFFEL-DAY-10/"><![CDATA[<h1 id="20210111">20210111</h1>

<p>오전 : 머신러닝이란? 딥러닝이란? 에서 출발하는 질문들을 점차 심층적으로 내려가는 질문들의 사례를 보았다.</p>

<h2 id="cs231n-03-02">CS231n-03-02</h2>

<h3 id="optimization">Optimization</h3>

<p>계곡에 있다고 생각하고, 우리는 계곡의 가장 낮은 밑바닥을 찾아내는 것이 목적이다. 지금 우리가 있는 곳의 높이가 loss, 그리고 밑바닥을 찾아가는 여정이 optimization과정이 된다. 풍경은 파라미터 W를 의미한다. W는 loss에 따라서 달라지니까.</p>

<p>loss를 줄이는 방법은 Random search 방법이 있다.  (정확도 15.5퍼센트 정도 나온다고…)</p>

<p>두 번째 방법으로 경사의 기울기에 따라서 길을 찾아볼까?(NN, Linear regression)</p>

<p>특정 지점에서 미분을 해서 기울기를 구해보자. 그렇다면 각 변수에 대한 편미분함수의 조합이 되겠지. 유닛벡터와 gradient의 조합이 해당 지점에서의 기울기를 알려줄 것이다.</p>

<h5 id="수치적인-방법">수치적인 방법</h5>

<p>현재 W-&gt;W+h(W의 각 dimension에 대해서 이를 반복한다.)-&gt;gradient인 dW 확인 =&gt; 이거 진짜 느리고 각 dimension에 대해서 함수 계산을 다시 계산해야 해서 시간 너무 걸린다. <strong>다만 디버깅을 위해서 쓰일 수 있다.</strong> 유닛 테스트 처럼. 이때는 파라미터를 줄여서 실시한다. (gradient check)</p>

<p>정리하면 근접적이고, 느리고, 적기에는 편하다.</p>

<h5 id="분석적인-방법">분석적인 방법</h5>

<p>시간을 축소하기 위해 걸리는 방식 : loss function을 적어놓고 미분함수를 구한 후 이의 극한을 구한다.</p>

<p>정리하면 빠르고, 정확하다. 근데 실수하기 쉬움.</p>

<table>
  <tbody>
    <tr>
      <td>![Tuning the learning rate in Gradient Descent</td>
      <td>Datumbox](https://blog.datumbox.com/wp-content/uploads/2013/10/gradient-descent.png)</td>
    </tr>
  </tbody>
</table>

<h5 id="gradient-descent">Gradient descent</h5>

<p>W를 임의의 값으로 초기화한다. 그리고 gradient(접평면에 수직인 백터)가 -로 나오는 방향으로 weight를 조정해줄 것이다. 스텝 사이즈를 통해서 학습을 했을 때, 그 학습의 속도를 Learning Rate라고 한다. Step size는 하이퍼파라미터의 하나이다. 학습의 방향에 중요한 역할을 한다.</p>

<p>효과적인 Gradient descent를 위해서 이전 Gradient descent 결과에 피드백을 주는 방법이 있다.</p>

<p>Q. step size vs learning rate vs batch size</p>

<p>step size : 보폭의 크기</p>

<p>learning rate : 보폭의 크기 내에서도 한번에 학습하는 정도…?</p>

<p>Gradient descent에 대해서 더 참고하려면 여기를~</p>

<p>https://seamless.tistory.com/38</p>

<p><img src="https://t1.daumcdn.net/cfile/tistory/993D383359D86C280D" alt="img" /></p>

<h5 id="stochastic-gradient-descentsgd">Stochastic Gradient Descent(SGD)</h5>

<p>만약 N이 엄청나게 크면 어떡하지? 실제 gradient를 계산하려면 N개의 데이터를 돌면서 다 반영해야 할 것이다. 그래서 전체 데이터 셋의 gradient와 loss를 다 계산하기 보다는 Minibatch를 쓴다.(2의 승수를 주로 쓴다.) 그러니까 전체 집단 보다 데이터 셋에서 임의의 minibatch를 구해서 거기서 loss와 gradient를 구한다.</p>

<p>cf) Optimizer 계보 참조해서 넣기</p>

<h5 id="image-features-학습하기">Image Features 학습하기</h5>

<p>이전에는 여러 속성들을 벡터로 엮어서 Linear classification에 입력했다. Feature들을 transform해서 선형 분류가 되도록 바꾼다거나. 예를 들자면 컬러 히스토그램이 있다. 이미지에서 Hue값만 뽑아서 색깔 테이블에 매칭해 보는 것이다.</p>

<p>Histogram Oriented Gradient : local gradient을 통해서 각 local별로 어떤 edge가 존재하는지 알아볼 수 있다. 그리고 해당 local에서 어떤 vector가 많이 등장하는지 양동이에 담는다. 예를 들어 자연어 처리에서 Bag of Words에서 문장의 여러 단어의 발생 빈도를 재서 양동이에 담는 경우를 떠올릴 수 있다. 이미지의 경우는 많은 이미지를 구해서, 이 이미지를 조각조각낸 후, 그 조각에서 
“virtual words”를 찾아낸다. 이를 모은 것을 “code book”이라고 할 때, 이 code book에 따라 이미지를 분류할 수 있을 것이다.</p>

<p>10년 전만 해도 이미지 입력-&gt;BOW/HOG-&gt;특징 추출-&gt;분류기에 입력. 한번 이미지의 속성이 추출되면, 이는 변하지 않는다. 분류기만 학습이 될 뿐.</p>

<p>딥러닝은 이제 이 속성까지 스스로 추출해 낸다는 것!</p>

<h2 id="cs231-04-01">CS231-04-01</h2>

<h3 id="backpropagation-and-neural-networks">Backpropagation and Neural Networks</h3>

<p>어떻게 분석적인 방법을 통해 gradient descent를 실행하는가?</p>

<p>computational graph를 그려서 뉴럴 네트워크의 구조를 설명하더라.</p>

<h5 id="backpropagation">Backpropagation</h5>

<p>뒤에서부터 앞으로 반대방향으로 편미분을 한다.</p>

<p>그렇다면 Backpropagation을 왜 하냐?(What is backpropagation really doing?) : 해당 네트워크가 제대로 학습하고 있는지를 알아보기 위해서 디버깅하는 과정이다. output으로 loss값을 구했다면, 이 다음 학습을 위해 weight를 새롭게 정비해야 한다. 따라서 역으로 거슬러 올라가면서 weight 값들을 변경하게 된다.</p>

<p>local gradient (편미분을 통해서)</p>

<p>해당 노드에서 local gradient를 구할려면 이전 노드 결과 x, y가 있다 치면 최종 loss function을 x,y로 편미분한 값들을 구한다. (chain rule을 통해 편미분 구함) output 값인 loss값이 상수이기 때문에 여기서 local gradient를 구할 수 있고, 이는 이전의 W에 -피드백을 하기 위해 쓰인다.(Gradient가 -여야 아래로 내려가는 방향의 피드백을 할 수 있기 때문에. 그래프를 생각해 보자.)</p>

<p>결론 : 정방향으로 갈 때는 모델에 데이터가 지나가면서 최종 학습 결과를 내놓는다. 역방향으로 갈 때는 최종 학습 결과와 loss값을 이용해서 각 레이어 사이의 weight값을 조정한다. 왔다 갔다, 핑퐁핑퐁.</p>

<h3 id="후기">후기</h3>

<p>아침에 진짜 읽어볼 양이 많았다. 노드를 수행하기가 좀 버거웠고, 아침에 약한 타입임을 다시 한번 느꼈다. 이런. 오후 시간은 Backpropagation이 왜 이루어지는지 드디어 알아냈다! 학부시간에 주입식으로 들었던 시간들이 억울할 지경이다. 오늘도 이렇게 한발짝 나아간다.</p>]]></content><author><name>Hyemi Jeong</name></author><category term="Blog" /><category term="AI" /><category term="AIFFEL" /><category term="MODULAB" /><summary type="html"><![CDATA[20210111]]></summary></entry></feed>